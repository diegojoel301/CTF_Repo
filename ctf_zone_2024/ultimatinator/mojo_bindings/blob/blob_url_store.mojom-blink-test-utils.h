// third_party/blink/public/mojom/blob/blob_url_store.mojom-blink-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_BLOB_BLOB_URL_STORE_MOJOM_BLINK_TEST_UTILS_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_BLOB_BLOB_URL_STORE_MOJOM_BLINK_TEST_UTILS_H_

#include "third_party/blink/public/mojom/blob/blob_url_store.mojom-blink.h"
#include "third_party/blink/renderer/platform/platform_export.h"


namespace blink::mojom::blink {


class PLATFORM_EXPORT BlobURLStoreInterceptorForTesting : public BlobURLStore {
  virtual BlobURLStore* GetForwardingInterface() = 0;
  void Register(::mojo::PendingRemote<::blink::mojom::blink::Blob> blob, const ::blink::KURL& url, const ::base::UnguessableToken& unsafe_agent_cluster_id, const std::optional<::blink::BlinkSchemefulSite>& unsafe_top_level_site, RegisterCallback callback) override;
  void Revoke(const ::blink::KURL& url) override;
  void ResolveAsURLLoaderFactory(const ::blink::KURL& url, ::mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> factory, ResolveAsURLLoaderFactoryCallback callback) override;
  void ResolveForNavigation(const ::blink::KURL& url, ::mojo::PendingReceiver<BlobURLToken> token, ResolveForNavigationCallback callback) override;
};
class PLATFORM_EXPORT BlobURLStoreAsyncWaiter {
 public:
  explicit BlobURLStoreAsyncWaiter(BlobURLStore* proxy);

  BlobURLStoreAsyncWaiter(const BlobURLStoreAsyncWaiter&) = delete;
  BlobURLStoreAsyncWaiter& operator=(const BlobURLStoreAsyncWaiter&) = delete;

  ~BlobURLStoreAsyncWaiter();
  void Register(
      ::mojo::PendingRemote<::blink::mojom::blink::Blob> blob, const ::blink::KURL& url, const ::base::UnguessableToken& unsafe_agent_cluster_id, const std::optional<::blink::BlinkSchemefulSite>& unsafe_top_level_site);
  
  void ResolveAsURLLoaderFactory(
      const ::blink::KURL& url, ::mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> factory, std::optional<::base::UnguessableToken>* out_unsafe_agent_cluster_id, std::optional<::blink::BlinkSchemefulSite>* out_unsafe_top_level_site);
  
  void ResolveForNavigation(
      const ::blink::KURL& url, ::mojo::PendingReceiver<BlobURLToken> token, std::optional<::base::UnguessableToken>* out_unsafe_agent_cluster_id);
  std::optional<::base::UnguessableToken> ResolveForNavigation(const ::blink::KURL& url, ::mojo::PendingReceiver<BlobURLToken> token);

 private:
  BlobURLStore* const proxy_;
};


class PLATFORM_EXPORT BlobURLTokenInterceptorForTesting : public BlobURLToken {
  virtual BlobURLToken* GetForwardingInterface() = 0;
  void Clone(::mojo::PendingReceiver<BlobURLToken> token) override;
  void GetToken(GetTokenCallback callback) override;
};
class PLATFORM_EXPORT BlobURLTokenAsyncWaiter {
 public:
  explicit BlobURLTokenAsyncWaiter(BlobURLToken* proxy);

  BlobURLTokenAsyncWaiter(const BlobURLTokenAsyncWaiter&) = delete;
  BlobURLTokenAsyncWaiter& operator=(const BlobURLTokenAsyncWaiter&) = delete;

  ~BlobURLTokenAsyncWaiter();
  void GetToken(
      ::base::UnguessableToken* out_token);
  ::base::UnguessableToken GetToken();

 private:
  BlobURLToken* const proxy_;
};




}  // blink::mojom::blink

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_BLOB_BLOB_URL_STORE_MOJOM_BLINK_TEST_UTILS_H_